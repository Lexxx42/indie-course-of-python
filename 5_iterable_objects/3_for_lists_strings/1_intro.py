# Цикл for. Обход списков и строк

# Цикл for широко используется для обхода упорядоченных коллекций list и str,
# с которыми мы с вами уже познакомились.
# На этом занятии мы ознакомимся с тем,
# как обходить списки и строки при помощи цикла for. Делать мы можем это двумя способами:
#
# Обход элементов коллекции по значению
# Обход элементов коллекции по индексу(порядковому номеру)

# Обход коллекции по значению в цикле for
# Создадим список из нескольких чисел и используем цикл for для их обхода,
# все очень похоже как мы это делали с range

a = [43, 65, 3, 54, 6]
for i in a:
    print(i)

# В итоге цикл for поочередно присвоил переменной i каждое из значений,
# присутствующих в списке.
# Можно усовершенствовать данный код,
# добавив в него счетчик, который будет отображать какой это обход по очереди.
# И поставим команду input(),
# чтобы в программе после каждого обхода была пауза до тех пор, пока не нажмете enter.
# Теперь код выглядит следующим образом:

a = [43, 65, 3, 54, 6]
count = 0
for i in a:
    print(i)
    count += 1
    print(count, "обход")
    input('press enter to continue')

# Из программы мы видим, что цикл for выполняется столько раз, сколько и элементов в нашем списке.

# Если каждый элемент нашего списка необходимо будет увеличить, допустим на 5,
# то первой мыслью будет просто увеличить нашу переменную на 5 следующим образом:

a = [43, 65, 3, 54, 6]
for i in a:
    i += 5
    print(i, end=" ")
print()
print(a)

# Как мы видим, несмотря на то, что каждый раз переменная i увеличивалась на 5,
# список никак не изменился.
# Это связано с тем, что в переменной i сохраняется лишь дубль этого значения
# и из-за этого копия никак не влияет на оригинал из списка.
# Из этого следует, что при таком обходе в переменной i сохраняется значение списка
# и через эту переменную нельзя сохранить сам элемент.

# Теперь представим другую задачу:
# нам необходимо обойти все элементы и указать на каком месте стоит каждый из элементов.
# Код будет следующим:

a = [43, 65, 3, 54, 6]
for i in a:
    print(i, a.index(i))

# Здесь видно, что 43 стоит на нулевом месте, 65 на первом и т.д.
# Но если в нашем списке появится дубль, то наша программа перестанет правильно работать.
# Посмотрим это на примере со следующим списком:

a = [43, 65, 3, 43, 6]
for i in a:
    print(i, a.index(i))

# Как мы видим, у первого и предпоследнего элемента одинаковый индекс,
# поскольку метод index() ищет значение i с самого начала списка,
# следовательно когда берём значение 43, то мы получаем нулевой индекс быстрее, чем третий.
# Из этого делаем вывод, что при подобном варианте обхода
# у нас нет возможности получить достоверную информацию о номере элемента в списке.

# Следовательно, когда мы обходим список по значениям, имеем 2 минуса:

# не можем изменять элементы этого списка;
# не знаем на каких местах стоят элементы.

# Обход коллекции по индексу в цикле for

# А теперь рассмотрим другой вариант обхода элементов списка – обход по индексам.
# Мы знаем, что у каждого элемента списка есть свой порядковый номер.
# Первый элемент имеет порядковый номер 0, и дальше по возрастанию.
# Таким образом, чтобы пройти циклом for по списку,
# обращаясь к индексам должна быть следующая запись:

a = [43, 65, 3, 43, 6]
for i in range(5):
    print(i, a[i])

# Мы видим, что программа работает так,
# как нам нужно и нет той проблемы, что у второго числа 43 тот же индекс, что и у первого.

# Но у этого кода есть другой изъян,
# который можно увидеть, если добавить ещё одно число в список:

a = [43, 65, 3, 43, 6, 43]
for i in range(5):
    print(i, a[i])

# Мы получим ту же запись, что и при прошлом коде.
# Это связано с тем, что в функции range() у нас стоит 5 и мы её не поменяли.

# Стоит обратить внимание, что в функции  range может быть число меньшее,
# чем количество элементов списка (в таком случае просто будет обработаны не все числа списка),
# но в range не может быть число, превышающее число элементов в списке (тогда возникнет ошибка).
# На примере выглядит так, что:

a = [43, 65, 3, 43]
# этот цикл работает
for i in range(3):
    print(i, a[i])
print('-' * 20)
# здесь выходим за границы списка
a = [43, 65]
for i in range(3):
    print(i, a[i])

# Поэтому лучше в функции range() указывать число, равное длине списка.
# Длину списка можно указать в отдельной переменной или можно сразу использовать в функции range().
# Следующий код будет работать вне зависимости от того, какое количество элементов в нашем списке:

a = [43, 65, 3, 43]
b = len(a)
for i in range(b):
    print(i, a[i])

# При таком варианте обхода можно избавиться и от второй ошибки – невозможности изменения элементов списка.
# Давайте всё-таки увеличим каждую переменную в списке на 5:

a = [43, 65, 3, 43]
b = len(a)
for i in range(b):
    a[i] += 5
print(a)

# В итоге имеем, что при таком варианте обхода у нас есть возможность обращаться как к индексу элемента,
# так и к его значению, но обращаться к значению необходимо через его индекс.
# При этом мы можем изменить элементы списка при такой надобности.

# Из этого следует, что обход по индексам является более универсальным способом,
# чем обход по значениям, поэтому он является более предпочтительным.
# Обход по значениям применяется там, где нужны только значения из списка,
# это к примеру: просуммировать элементы списка, найти максимальное/минимальное значение.
# Но если в задаче необходимо узнать номер какого-то элемента или работать с соседними элементами,
# то необходимо работать с обходом по индексам.

# Разберём несколько примеров

# Необходимо предоставить список, из которого исключены дубли.

# Поскольку для исключения дублей нам не нужны индексы,
# тогда можно воспользоваться обходом по значениям.
# Нам необходимо создать второй список
# и при помощи цикла for проверить есть ли каждый элемент списка a в списке b.
# Если элемента нет, тогда элемент добавляется,
# если подобный элемент есть – переходим к следующему элементу.
# Вот пример того, какой должен быть код в таком случае:

a = [1, 2, 3, 4, 32, 4, 5, 3, 5]
b = []
for i in a:
    if i not in b:
        b.append(i)
print(b)

# Теперь из списка a получим 2 списка: индексы с четными и нечётными числами.
# Если нужны номера индекса, то обходим по индексам.
# Для этого необходимо в цикле for вставить условный оператор,
# который будет проверять делится ли число без остатка на 2.
# Если да, то в список чётных, в противном случае – в список нечетных.

a = [1, 2, 3, 4, 32, 4, 5, 3, 5]
chet = []
nechet = []
n = len(a)
for i in range(n):
    if a[i] % 2 == 0:
        chet.append(i)
    else:
        nechet.append(i)
print(chet)
print(nechet)

# Теперь мы видим на каких позициях в списке находятся четные и нечетные числа.

# Все эти варианты обхода списков работают и со строками.
# Обойдем строку по значениям:

s = "hElLo"
for i in s:
    print(i)

# Можно устроить проверку является ли буква маленькой или нет:

s = "hElLo2"
for i in s:
    if i >= "a" and i <= "z":
        print(i, "small")
    elif i >= "A" and i <= "Z":
        print(i, "big")
    else:
        print(i)

# Рассмотрим ещё один пример. В английском гласными являются следующие буквы: aeiou

# И допустим у нас есть строка со случайным набором букв и нам нужно вывести пары соседних букв,
# в которых обе буквы являются гласными.

# До этого мы работали лишь с одним элементом, а теперь у нас их 2.
# Будем работать с соседом справа, это означает,
# что если у первого элемента индекс [0], то у второго [1],
# если у первого [1], то у второго [2] и т.д.

# В общем виде это выглядит так: s[i] --> s[i+1]

# А если нам нужны индексы, то обходим строку по ним.
# Для начала попробуем просто вывести все пары:

vowels = "aeiou"
s = "aeriooikjoaikl"
n = len(s)
for i in range(n):
    print(s[i], s[i + 1])

# Мы вывели все элементы, но получили в конце ошибку.
# Это связано с тем, что когда мы обращаемся к правому соседу последней буквы
# мы выходим за границы строки
# (т.к. при принте последней буквы l мы не можем напечатать элемент дальше, чем l).

# Отсюда делаем следующий вывод,
# когда мы обращаемся к паре справа, то мы должны обходить до предпоследнего элемента,
# если обращаемся к паре слева, то мы должны обходить, начиная со второго элемента.
# Так что правильной будет следующая запись:

vowels = "aeiou"
s = "aeriooikjoaikl"
n = len(s)
for i in range(n - 1):
    print(s[i], s[i + 1])

# Осталось только добавить проверку:

vowels = "aeiou"
s = "aeriooikjoaikl"
n = len(s)
for i in range(n - 1):
    if s[i] in vowels and s[i + 1] in vowels:
        print(s[i], s[i + 1])
