# range - страшное животное.

# Введя в консоли range(-10), видим, что воспринято это как по умолчанию стартовый ноль,
# явно указанная граница "минус десять", но не указано,
# что дефолтный, маму его, шаг итерации равен плюс один,
# что явно с каждым шагом отдаляло бы его от финишной "минус десять",
# поэтому генерация не запускается вообще.
# Это из серии "просто живите с этим".

# Питон за всю свою эволюцию не научился определять направление вектора отсчёта
# - как будто там есть больше одного варианта.
# Поэтому приходится уточнять, что с десятого этажа в подвал - это вниз,
# а не вверх, иначе лифтёр вообще не шевельнётся.

# И насчёт iter. Такие "итерированные объекты" - одноразовые. Обьясняю. Обычный перечисляемый объект:

# a = [*range(10)]

# print(a)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# print(a)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Сколько угодно, хоть сто раз вывести - вот оно. Теперь итерируем:

# s = iter(a)
# s
# <list_iterator object at 0x7f567b4d2d40>
# print([*s])
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# print([*s])
# []

# Балалайку!
# Данные выводятся только один раз, назад дороги нет,
# вот то самое StopIteration, "перечисление окончено".

# Единственный способ - повторить вызов итератора заново.
# Вот на этом моменте лично я сгрыз пару табуреток, пока понял.
# Потому что нигде в сети упоминания об этой небольшой подробности не встречал ни разу.

print(range(-10))  # range(0, -10)

# Ранги от нуля до n содержать ровно n элементо,
# а ранги от m до n содержат n - m элементов.
# По сути ранг это открытый сверху интервал.
# В первом случае range(n) это интервал [0..n),
# а во втором range(m, n) это [m..n).

# Если бы речь шла об отрезках, то элементов там всегда на 1 больше чем в открытом сверху интервале :).
# Если дан ранг с шагом отличным от единицы,
# то для подсчета кол-ва элементов лучше составить линейное неравенство,
# чтобы не допустить ошибку.
# Например, для ранга list(range(20, 8, -3)) c отрицательным шагом -3 получается следующее неравенство:

# 20 - 3 * (t - 1) > 8

# Тут взято t - 1 потому что параметр t  начинается с нуля,
# а мы хотим чтобы он начинался с 1 и определял кол-во элементов в ранге.
# Решаем это и получаем t < 5, т.е. t = 4.

# или по другому для последнего примера list(range(20, 8, -3)) можно было составить неравенство:

# 20 - 3 * t > 8
# получаем решение в целых числах:

# t < 4  => 3.
#  но поскольку счет для переменной t велся с нуля,
#  то к результату накидываем единицу t = 3 + 1 = 4.
